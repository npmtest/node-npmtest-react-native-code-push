{"/home/travis/build/npmtest/node-npmtest-react-native-code-push/test.js":"/* istanbul instrument in package npmtest_react_native_code_push */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/lib.npmtest_react_native_code_push.js":"/* istanbul instrument in package npmtest_react_native_code_push */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_react_native_code_push = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_react_native_code_push = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-react-native-code-push && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_react_native_code_push */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_react_native_code_push\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_react_native_code_push.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_react_native_code_push.rollup.js'] =\n            local.assetsDict['/assets.npmtest_react_native_code_push.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_react_native_code_push.__dirname + '/lib.npmtest_react_native_code_push.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/CodePush.js":"import { AcquisitionManager as Sdk } from \"code-push/script/acquisition-sdk\";\nimport { Alert } from \"./AlertAdapter\";\nimport requestFetchAdapter from \"./request-fetch-adapter\";\nimport { AppState, Platform } from \"react-native\";\nimport RestartManager from \"./RestartManager\";\nimport log from \"./logging\";\n\nlet NativeCodePush = require(\"react-native\").NativeModules.CodePush;\nconst PackageMixins = require(\"./package-mixins\")(NativeCodePush);\n\nasync function checkForUpdate(deploymentKey = null) {\n  /*\n   * Before we ask the server if an update exists, we\n   * need to retrieve three pieces of information from the\n   * native side: deployment key, app version (e.g. 1.0.1)\n   * and the hash of the currently running update (if there is one).\n   * This allows the client to only receive updates which are targetted\n   * for their specific deployment and version and which are actually\n   * different from the CodePush update they have already installed.\n   */\n  const nativeConfig = await getConfiguration();\n\n  /*\n   * If a deployment key was explicitly provided,\n   * then let's override the one we retrieved\n   * from the native-side of the app. This allows\n   * dynamically \"redirecting\" end-users at different\n   * deployments (e.g. an early access deployment for insiders).\n   */\n  const config = deploymentKey ? { ...nativeConfig, ...{ deploymentKey } } : nativeConfig;\n  const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n\n  // Use dynamically overridden getCurrentPackage() during tests.\n  const localPackage = await module.exports.getCurrentPackage();\n\n  /*\n   * If the app has a previously installed update, and that update\n   * was targetted at the same app version that is currently running,\n   * then we want to use its package hash to determine whether a new\n   * release has been made on the server. Otherwise, we only need\n   * to send the app version to the server, since we are interested\n   * in any updates for current app store version, regardless of hash.\n   */\n  let queryPackage;\n  if (localPackage) {\n    queryPackage = localPackage;\n  } else {\n    queryPackage = { appVersion: config.appVersion };\n    if (Platform.OS === \"ios\" && config.packageHash) {\n      queryPackage.packageHash = config.packageHash;\n    }\n  }\n\n  const update = await sdk.queryUpdateWithCurrentPackage(queryPackage);\n\n  /*\n   * There are four cases where checkForUpdate will resolve to null:\n   * ----------------------------------------------------------------\n   * 1) The server said there isn't an update. This is the most common case.\n   * 2) The server said there is an update but it requires a newer binary version.\n   *    This would occur when end-users are running an older app store version than\n   *    is available, and CodePush is making sure they don't get an update that\n   *    potentially wouldn't be compatible with what they are running.\n   * 3) The server said there is an update, but the update's hash is the same as\n   *    the currently running update. This should _never_ happen, unless there is a\n   *    bug in the server, but we're adding this check just to double-check that the\n   *    client app is resilient to a potential issue with the update check.\n   * 4) The server said there is an update, but the update's hash is the same as that\n   *    of the binary's currently running version. This should only happen in Android -\n   *    unlike iOS, we don't attach the binary's hash to the updateCheck request\n   *    because we want to avoid having to install diff updates against the binary's\n   *    version, which we can't do yet on Android.\n   */\n  if (!update || update.updateAppVersion ||\n      localPackage && (update.packageHash === localPackage.packageHash) ||\n      (!localPackage || localPackage._isDebugOnly) && config.packageHash === update.packageHash) {\n    if (update && update.updateAppVersion) {\n      log(\"An update is available but it is not targeting the binary version of your app.\");\n    }\n\n    return null;\n  } else {\n    const remotePackage = { ...update, ...PackageMixins.remote(sdk.reportStatusDownload) };\n    remotePackage.failedInstall = await NativeCodePush.isFailedUpdate(remotePackage.packageHash);\n    remotePackage.deploymentKey = deploymentKey || nativeConfig.deploymentKey;\n    return remotePackage;\n  }\n}\n\nconst getConfiguration = (() => {\n  let config;\n  return async function getConfiguration() {\n    if (config) {\n      return config;\n    } else if (testConfig) {\n      return testConfig;\n    } else {\n      config = await NativeCodePush.getConfiguration();\n      return config;\n    }\n  }\n})();\n\nasync function getCurrentPackage() {\n  return await getUpdateMetadata(CodePush.UpdateState.LATEST);\n}\n\nasync function getUpdateMetadata(updateState) {\n  let updateMetadata = await NativeCodePush.getUpdateMetadata(updateState || CodePush.UpdateState.RUNNING);\n  if (updateMetadata) {\n    updateMetadata = {...PackageMixins.local, ...updateMetadata};\n    updateMetadata.failedInstall = await NativeCodePush.isFailedUpdate(updateMetadata.packageHash);\n    updateMetadata.isFirstRun = await NativeCodePush.isFirstRun(updateMetadata.packageHash);\n  }\n  return updateMetadata;\n}\n\nfunction getPromisifiedSdk(requestFetchAdapter, config) {\n  // Use dynamically overridden AcquisitionSdk during tests.\n  const sdk = new module.exports.AcquisitionSdk(requestFetchAdapter, config);\n  sdk.queryUpdateWithCurrentPackage = (queryPackage) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.queryUpdateWithCurrentPackage.call(sdk, queryPackage, (err, update) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(update);\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDeploy = (deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.reportStatusDeploy.call(sdk, deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDownload = (downloadedPackage) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.reportStatusDownload.call(sdk, downloadedPackage, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  return sdk;\n}\n\n// This ensures that notifyApplicationReadyInternal is only called once\n// in the lifetime of this module instance.\nconst notifyApplicationReady = (() => {\n  let notifyApplicationReadyPromise;\n  return () => {\n    if (!notifyApplicationReadyPromise) {\n      notifyApplicationReadyPromise = notifyApplicationReadyInternal();\n    }\n\n    return notifyApplicationReadyPromise;\n  };\n})();\n\nasync function notifyApplicationReadyInternal() {\n  await NativeCodePush.notifyApplicationReady();\n  const statusReport = await NativeCodePush.getNewStatusReport();\n  statusReport && tryReportStatus(statusReport); // Don't wait for this to complete.\n\n  return statusReport;\n}\n\nasync function tryReportStatus(statusReport, resumeListener) {\n  const config = await getConfiguration();\n  const previousLabelOrAppVersion = statusReport.previousLabelOrAppVersion;\n  const previousDeploymentKey = statusReport.previousDeploymentKey || config.deploymentKey;\n  try {\n    if (statusReport.appVersion) {\n      log(`Reporting binary update (${statusReport.appVersion})`);\n\n      const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n      await sdk.reportStatusDeploy(/* deployedPackage */ null, /* status */ null, previousLabelOrAppVersion, previousDeploymentKey);\n    } else {\n      const label = statusReport.package.label;\n      if (statusReport.status === \"DeploymentSucceeded\") {\n        log(`Reporting CodePush update success (${label})`);\n      } else {\n        log(`Reporting CodePush update rollback (${label})`);\n      }\n\n      config.deploymentKey = statusReport.package.deploymentKey;\n      const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n      await sdk.reportStatusDeploy(statusReport.package, statusReport.status, previousLabelOrAppVersion, previousDeploymentKey);\n    }\n\n    NativeCodePush.recordStatusReported(statusReport);\n    resumeListener && AppState.removeEventListener(\"change\", resumeListener);\n  } catch (e) {\n    log(`Report status failed: ${JSON.stringify(statusReport)}`);\n    NativeCodePush.saveStatusReportForRetry(statusReport);\n    // Try again when the app resumes\n    if (!resumeListener) {\n      resumeListener = async (newState) => {\n        if (newState !== \"active\") return;\n        const refreshedStatusReport = await NativeCodePush.getNewStatusReport();\n        if (refreshedStatusReport) {\n          tryReportStatus(refreshedStatusReport, resumeListener);\n        } else {\n          AppState.removeEventListener(\"change\", resumeListener);\n        }\n      };\n      AppState.addEventListener(\"change\", resumeListener);\n    }\n  }\n}\n\nvar testConfig;\n\n// This function is only used for tests. Replaces the default SDK, configuration and native bridge\nfunction setUpTestDependencies(testSdk, providedTestConfig, testNativeBridge) {\n  if (testSdk) module.exports.AcquisitionSdk = testSdk;\n  if (providedTestConfig) testConfig = providedTestConfig;\n  if (testNativeBridge) NativeCodePush = testNativeBridge;\n}\n\n// This function allows only one syncInternal operation to proceed at any given time.\n// Parallel calls to sync() while one is ongoing yields CodePush.SyncStatus.SYNC_IN_PROGRESS.\nconst sync = (() => {\n  let syncInProgress = false;\n  const setSyncCompleted = () => { syncInProgress = false; };\n\n  return (options = {}, syncStatusChangeCallback, downloadProgressCallback) => {\n    if (syncInProgress) {\n      typeof syncStatusChangeCallback === \"function\"\n        ? syncStatusChangeCallback(CodePush.SyncStatus.SYNC_IN_PROGRESS)\n        : log(\"Sync already in progress.\");\n      return Promise.resolve(CodePush.SyncStatus.SYNC_IN_PROGRESS);\n    }\n\n    syncInProgress = true;\n    const syncPromise = syncInternal(options, syncStatusChangeCallback, downloadProgressCallback);\n    syncPromise\n      .then(setSyncCompleted)\n      .catch(setSyncCompleted);\n\n    return syncPromise;\n  };\n})();\n\n/*\n * The syncInternal method provides a simple, one-line experience for\n * incorporating the check, download and installation of an update.\n *\n * It simply composes the existing API methods together and adds additional\n * support for respecting mandatory updates, ignoring previously failed\n * releases, and displaying a standard confirmation UI to the end-user\n * when an update is available.\n */\nasync function syncInternal(options = {}, syncStatusChangeCallback, downloadProgressCallback) {\n  let resolvedInstallMode;\n  const syncOptions = {\n    deploymentKey: null,\n    ignoreFailedUpdates: true,\n    installMode: CodePush.InstallMode.ON_NEXT_RESTART,\n    mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,\n    minimumBackgroundDuration: 0,\n    updateDialog: null,\n    ...options\n  };\n\n  syncStatusChangeCallback = typeof syncStatusChangeCallback === \"function\"\n    ? syncStatusChangeCallback\n    : (syncStatus) => {\n        switch(syncStatus) {\n          case CodePush.SyncStatus.CHECKING_FOR_UPDATE:\n            log(\"Checking for update.\");\n            break;\n          case CodePush.SyncStatus.AWAITING_USER_ACTION:\n            log(\"Awaiting user action.\");\n            break;\n          case CodePush.SyncStatus.DOWNLOADING_PACKAGE:\n            log(\"Downloading package.\");\n            break;\n          case CodePush.SyncStatus.INSTALLING_UPDATE:\n            log(\"Installing update.\");\n            break;\n          case CodePush.SyncStatus.UP_TO_DATE:\n            log(\"App is up to date.\");\n            break;\n          case CodePush.SyncStatus.UPDATE_IGNORED:\n            log(\"User cancelled the update.\");\n            break;\n          case CodePush.SyncStatus.UPDATE_INSTALLED:\n            if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESTART) {\n              log(\"Update is installed and will be run on the next app restart.\");\n            } else if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESUME) {\n              if (syncOptions.minimumBackgroundDuration > 0) {\n                log(`Update is installed and will be run after the app has been in the background for at least ${syncOptions.minimumBackgroundDuration} seconds.`);\n              } else {\n                log(\"Update is installed and will be run when the app next resumes.\");\n              }\n            }\n            break;\n          case CodePush.SyncStatus.UNKNOWN_ERROR:\n            log(\"An unknown error occurred.\");\n            break;\n        }\n      };\n\n  try {\n    await CodePush.notifyApplicationReady();\n\n    syncStatusChangeCallback(CodePush.SyncStatus.CHECKING_FOR_UPDATE);\n    const remotePackage = await checkForUpdate(syncOptions.deploymentKey);\n\n    const doDownloadAndInstall = async () => {\n      syncStatusChangeCallback(CodePush.SyncStatus.DOWNLOADING_PACKAGE);\n      const localPackage = await remotePackage.download(downloadProgressCallback);\n\n      // Determine the correct install mode based on whether the update is mandatory or not.\n      resolvedInstallMode = localPackage.isMandatory ? syncOptions.mandatoryInstallMode : syncOptions.installMode;\n\n      syncStatusChangeCallback(CodePush.SyncStatus.INSTALLING_UPDATE);\n      await localPackage.install(resolvedInstallMode, syncOptions.minimumBackgroundDuration, () => {\n        syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n      });\n\n      return CodePush.SyncStatus.UPDATE_INSTALLED;\n    };\n\n    const updateShouldBeIgnored = remotePackage && (remotePackage.failedInstall && syncOptions.ignoreFailedUpdates);\n    if (!remotePackage || updateShouldBeIgnored) {\n      if (updateShouldBeIgnored) {\n          log(\"An update is available, but it is being ignored due to having been previously rolled back.\");\n      }\n\n      const currentPackage = await CodePush.getCurrentPackage();\n      if (currentPackage && currentPackage.isPending) {\n        syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n        return CodePush.SyncStatus.UPDATE_INSTALLED;\n      } else {\n        syncStatusChangeCallback(CodePush.SyncStatus.UP_TO_DATE);\n        return CodePush.SyncStatus.UP_TO_DATE;\n      }\n    } else if (syncOptions.updateDialog) {\n      // updateDialog supports any truthy value (e.g. true, \"goo\", 12),\n      // but we should treat a non-object value as just the default dialog\n      if (typeof syncOptions.updateDialog !== \"object\") {\n        syncOptions.updateDialog = CodePush.DEFAULT_UPDATE_DIALOG;\n      } else {\n        syncOptions.updateDialog = { ...CodePush.DEFAULT_UPDATE_DIALOG, ...syncOptions.updateDialog };\n      }\n\n      return await new Promise((resolve, reject) => {\n        let message = null;\n        const dialogButtons = [{\n          text: null,\n          onPress:() => {\n            doDownloadAndInstall()\n              .then(resolve, reject);\n          }\n        }];\n\n        if (remotePackage.isMandatory) {\n          message = syncOptions.updateDialog.mandatoryUpdateMessage;\n          dialogButtons[0].text = syncOptions.updateDialog.mandatoryContinueButtonLabel;\n        } else {\n          message = syncOptions.updateDialog.optionalUpdateMessage;\n          dialogButtons[0].text = syncOptions.updateDialog.optionalInstallButtonLabel;\n          // Since this is an optional update, add another button\n          // to allow the end-user to ignore it\n          dialogButtons.push({\n            text: syncOptions.updateDialog.optionalIgnoreButtonLabel,\n            onPress: () => {\n              syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_IGNORED);\n              resolve(CodePush.SyncStatus.UPDATE_IGNORED);\n            }\n          });\n        }\n\n        // If the update has a description, and the developer\n        // explicitly chose to display it, then set that as the message\n        if (syncOptions.updateDialog.appendReleaseDescription && remotePackage.description) {\n          message += `${syncOptions.updateDialog.descriptionPrefix} ${remotePackage.description}`;\n        }\n\n        syncStatusChangeCallback(CodePush.SyncStatus.AWAITING_USER_ACTION);\n        Alert.alert(syncOptions.updateDialog.title, message, dialogButtons);\n      });\n    } else {\n      return await doDownloadAndInstall();\n    }\n  } catch (error) {\n    syncStatusChangeCallback(CodePush.SyncStatus.UNKNOWN_ERROR);\n    log(error.message);\n    throw error;\n  }\n};\n\nlet CodePush;\n\nfunction codePushify(options = {}) {\n  let React;\n  let ReactNative = require(\"react-native\");\n\n  try { React = require(\"react\"); } catch (e) { }\n  if (!React) {\n    try { React = ReactNative.React; } catch (e) { }\n    if (!React) {\n      throw new Error(\"Unable to find the 'React' module.\");\n    }\n  }\n\n  if (!React.Component) {\n    throw new Error(\n`Unable to find the \"Component\" class, please either:\n1. Upgrade to a newer version of React Native that supports it, or\n2. Call the codePush.sync API in your component instead of using the @codePush decorator`\n    );\n  }\n\n  var decorator = (RootComponent) => {\n    return class CodePushComponent extends React.Component {\n      componentDidMount() {\n        if (options.checkFrequency === CodePush.CheckFrequency.MANUAL) {\n          CodePush.notifyAppReady();\n        } else {\n          let rootComponentInstance = this.refs.rootComponent;\n\n          let syncStatusCallback;\n          if (rootComponentInstance && rootComponentInstance.codePushStatusDidChange) {\n            syncStatusCallback = rootComponentInstance.codePushStatusDidChange;\n            if (rootComponentInstance instanceof React.Component) {\n              syncStatusCallback = syncStatusCallback.bind(rootComponentInstance);\n            }\n          }\n\n          let downloadProgressCallback;\n          if (rootComponentInstance && rootComponentInstance.codePushDownloadDidProgress) {\n            downloadProgressCallback = rootComponentInstance.codePushDownloadDidProgress;\n            if (rootComponentInstance instanceof React.Component) {\n              downloadProgressCallback = downloadProgressCallback.bind(rootComponentInstance);\n            }\n          }\n\n          CodePush.sync(options, syncStatusCallback, downloadProgressCallback);\n          if (options.checkFrequency === CodePush.CheckFrequency.ON_APP_RESUME) {\n            ReactNative.AppState.addEventListener(\"change\", (newState) => {\n              newState === \"active\" && CodePush.sync(options, syncStatusCallback, downloadProgressCallback);\n            });\n          }\n        }\n      }\n\n      render() {\n        return <RootComponent {...this.props} ref={\"rootComponent\"} />\n      }\n    }\n  }\n\n  if (typeof options === \"function\") {\n    // Infer that the root component was directly passed to us.\n    return decorator(options);\n  } else {\n    return decorator;\n  }\n}\n\n// If the \"NativeCodePush\" variable isn't defined, then\n// the app didn't properly install the native module,\n// and therefore, it doesn't make sense initializing\n// the JS interface when it wouldn't work anyways.\nif (NativeCodePush) {\n  CodePush = codePushify;\n  Object.assign(CodePush, {\n    AcquisitionSdk: Sdk,\n    checkForUpdate,\n    getConfiguration,\n    getCurrentPackage,\n    getUpdateMetadata,\n    log,\n    notifyAppReady: notifyApplicationReady,\n    notifyApplicationReady,\n    restartApp: RestartManager.restartApp,\n    setUpTestDependencies,\n    sync,\n    disallowRestart: RestartManager.disallow,\n    allowRestart: RestartManager.allow,\n    InstallMode: {\n      IMMEDIATE: NativeCodePush.codePushInstallModeImmediate, // Restart the app immediately\n      ON_NEXT_RESTART: NativeCodePush.codePushInstallModeOnNextRestart, // Don't artificially restart the app. Allow the update to be \"picked up\" on the next app restart\n      ON_NEXT_RESUME: NativeCodePush.codePushInstallModeOnNextResume // Restart the app the next time it is resumed from the background\n    },\n    SyncStatus: {\n      UP_TO_DATE: 0, // The running app is up-to-date\n      UPDATE_INSTALLED: 1, // The app had an optional/mandatory update that was successfully downloaded and is about to be installed.\n      UPDATE_IGNORED: 2, // The app had an optional update and the end-user chose to ignore it\n      UNKNOWN_ERROR: 3,\n      SYNC_IN_PROGRESS: 4, // There is an ongoing \"sync\" operation in progress.\n      CHECKING_FOR_UPDATE: 5,\n      AWAITING_USER_ACTION: 6,\n      DOWNLOADING_PACKAGE: 7,\n      INSTALLING_UPDATE: 8\n    },\n    CheckFrequency: {\n      ON_APP_START: 0,\n      ON_APP_RESUME: 1,\n      MANUAL: 2\n    },\n    UpdateState: {\n      RUNNING: NativeCodePush.codePushUpdateStateRunning,\n      PENDING: NativeCodePush.codePushUpdateStatePending,\n      LATEST: NativeCodePush.codePushUpdateStateLatest\n    },\n    DeploymentStatus: {\n      FAILED: \"DeploymentFailed\",\n      SUCCEEDED: \"DeploymentSucceeded\",\n    },\n    DEFAULT_UPDATE_DIALOG: {\n      appendReleaseDescription: false,\n      descriptionPrefix: \" Description: \",\n      mandatoryContinueButtonLabel: \"Continue\",\n      mandatoryUpdateMessage: \"An update is available that must be installed.\",\n      optionalIgnoreButtonLabel: \"Ignore\",\n      optionalInstallButtonLabel: \"Install\",\n      optionalUpdateMessage: \"An update is available. Would you like to install it?\",\n      title: \"Update available\"\n    }\n  });\n} else {\n  log(\"The CodePush module doesn't appear to be properly installed. Please double-check that everything is setup correctly.\");\n}\n\nmodule.exports = CodePush;\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/AlertAdapter.js":"import React, { Platform } from \"react-native\";\nlet { Alert } = React;\n\nif (Platform.OS === \"android\") {\n  const { NativeModules: { CodePushDialog } } = React;\n    \n  Alert = {\n    alert(title, message, buttons) {\n      if (buttons.length > 2) {\n        throw \"Can only show 2 buttons for Android dialog.\";\n      }\n      \n      const button1Text = buttons[0] ? buttons[0].text : null,\n            button2Text = buttons[1] ? buttons[1].text : null;\n      \n      CodePushDialog.showDialog(\n        title, message, button1Text, button2Text,\n        (buttonId) => { buttons[buttonId].onPress && buttons[buttonId].onPress(); }, \n        (error) => { throw error; });\n    }\n  };\n}\n\nmodule.exports = { Alert };","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/gulpfile.js":"var del = require(\"del\");\nvar gulp = require(\"gulp\");\nvar path = require(\"path\");\nvar child_process = require(\"child_process\");\nvar Q = require(\"q\");\nvar runSequence = require(\"run-sequence\");\n\nvar testPath = \"./test\";\nvar binPath = \"./bin\";\nvar tsFiles = \"/**/*.ts\";\n\nvar iOSSimulatorProcessName = \"Simulator\";\nvar emulatorReadyCheckDelay = 30 * 1000;\nvar emulatorMaxReadyAttempts = 5;\n\n/* This message is appended to the compiled JS files to avoid contributions to the compiled sources.*/\nvar compiledSourceWarningMessage = \"\\n \\\n/******************************************************************************************** \\n \\\n\t THIS FILE HAS BEEN COMPILED FROM TYPESCRIPT SOURCES. \\n \\\n\t PLEASE DO NOT MODIFY THIS FILE AS YOU WILL LOSE YOUR CHANGES WHEN RECOMPILING. \\n \\\n\t ALSO, PLEASE DO NOT SUBMIT PULL REQUESTS WITH CHANGES TO THIS FILE. \\n \\\n\t INSTEAD, EDIT THE TYPESCRIPT SOURCES UNDER THE WWW FOLDER. \\n \\\n\t FOR MORE INFORMATION, PLEASE SEE CONTRIBUTING.md. \\n \\\n*********************************************************************************************/ \\n\\n\\n\";\n\n/* TypeScript compilation parameters */\nvar tsCompileOptions = {\n    \"noImplicitAny\": true,\n    \"noEmitOnError\": true,\n    \"target\": \"ES5\",\n    \"module\": \"commonjs\",\n    \"sourceMap\": false,\n    \"sortOutput\": true,\n    \"removeComments\": true\n};\n\nfunction spawnCommand(command, args, callback, silent, detached) {\n    var options = { maxBuffer: 1024 * 1024 };\n    if (detached) {\n        options.detached = true;\n        options.stdio = [\"ignore\"];\n    }\n    \n    var spawnProcess = child_process.spawn(command, args, options);\n        \n    if (!silent) spawnProcess.stdout.pipe(process.stdout);\n    if (!silent) spawnProcess.stderr.pipe(process.stderr);\n\n    if (!detached) {\n        spawnProcess.on('exit', function (code) {\n            callback && callback(code === 0 ? undefined : \"Error code: \" + code);\n        });\n    }\n    \n    return spawnProcess;\n};\n\nfunction execCommand(command, args, callback, silent) {\n    var execProcess = child_process.exec(command + \" \" + args.join(\" \"), { maxBuffer: 1024 * 1024 });\n        \n    if (!silent) execProcess.stdout.pipe(process.stdout);\n    if (!silent) execProcess.stderr.pipe(process.stderr);\n    \n    execProcess.on('error', function (error) {\n        callback && callback(error);\n    })\n    \n    execProcess.on('exit', function (code) {\n        callback && callback(code === 0 ? undefined : \"Error code: \" + code);\n    });\n    \n    return execProcess;\n};\n\nfunction runTests(callback, options) {\n    var command = \"mocha\";\n    var args = [\"./bin/test\"];\n    \n    // pass arguments supplied by test tasks\n    if (options.android) args.push(\"--android\");\n    if (options.ios) args.push(\"--ios\");\n    if (options.setup) args.push(\"--setup\");\n    \n    // pass arguments from command line\n    // the fourth argument is the first argument after the task name\n    for (var i = 3; i < process.argv.length; i++) {\n        if (process.argv[i] === \"--report\") {\n            // Set up the mocha junit reporter.\n            args.push(\"--reporter\");\n            args.push(\"mocha-junit-reporter\");\n            \n            // Set the mocha reporter to the correct output file.\n            args.push(\"--reporter-options\");\n            var filename = \"./test-results.xml\";\n            if (options.android && !options.ios) filename = \"./test-android.xml\";\n            else if (options.ios && !options.android) filename = \"./test-ios.xml\";\n            args.push(\"mochaFile=\" + filename);\n            // Delete previous test result file so TFS doesn't read the old file if the tests exit before saving\n            del(filename);\n        } else args.push(process.argv[i]);\n    }\n    \n    execCommand(command, args, callback);\n}\n\ngulp.task(\"compile\", function (callback) {\n    runSequence(\"compile-test\", callback);\n});\n\ngulp.task(\"compile-test\", function () {\n    var ts = require(\"gulp-typescript\");\n    var insert = require(\"gulp-insert\");\n\n    return gulp.src([testPath + tsFiles])\n        .pipe(ts(tsCompileOptions))\n        .pipe(insert.prepend(compiledSourceWarningMessage))\n        .pipe(gulp.dest(path.join(binPath, testPath)));\n});\n\ngulp.task(\"tslint\", function () {\n    var tslint = require('gulp-tslint');\n\n    // Configuration options adapted from TypeScript project:\n    // https://github.com/Microsoft/TypeScript/blob/master/tslint.json\n\n    var config = {\n        \"rules\": {\n            \"class-name\": true,\n            \"comment-format\": [true,\n                \"check-space\"\n            ],\n            \"indent\": [true,\n                \"spaces\"\n            ],\n            \"one-line\": [true,\n                \"check-open-brace\"\n            ],\n            \"no-unreachable\": true,\n            \"no-unused-variable\": true,\n            \"no-use-before-declare\": true,\n            \"quotemark\": [true,\n                \"double\"\n            ],\n            \"semicolon\": true,\n            \"whitespace\": [true,\n                \"check-branch\",\n                \"check-operator\",\n                \"check-separator\",\n                \"check-type\"\n            ],\n            \"typedef-whitespace\": [true, {\n                \"call-signature\": \"nospace\",\n                \"index-signature\": \"nospace\",\n                \"parameter\": \"nospace\",\n                \"property-declaration\": \"nospace\",\n                \"variable-declaration\": \"nospace\"\n            }]\n        }\n    }\n\n    return gulp.src([testPath + tsFiles, \"!\" + testPath + \"/typings/*\"])\n        .pipe(tslint({ configuration: config }))\n        .pipe(tslint.report(\"verbose\"));\n});\n\ngulp.task(\"clean\", function () {\n    return del([binPath + \"/**\"], { force: true });\n});\n\ngulp.task(\"default\", function (callback) {\n    runSequence(\"clean\", \"compile\", \"tslint\", callback);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Test Tasks //////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////\n// Standalone Tasks\n//\n// Run the tests without setting up the test projects.\n// Don't run these without running a setup task first!\n\n// Run on Android standalone\ngulp.task(\"test-run-android\", function (callback) {\n    var options = {\n        android: true\n    };\n    \n    runTests(callback, options);\n});\n\n// Run on iOS standalone\ngulp.task(\"test-run-ios\", function (callback) {\n    var options = {\n        ios: true,\n        ui: true,\n    };\n    \n    runTests(callback, options);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Setup Tasks\n//\n// Sets up the test project directories that the tests use and starts emulators.\n// Must run before running a standalone suite of tests!\n\n// Sets up the test projects and starts an Android emulator\ngulp.task(\"test-setup-android\", function (callback) {\n    var options = {\n        setup: true,\n        android: true\n    };\n    \n    runTests(callback, options);\n});\n\n// Sets up the test projects and starts an iOS emulator\ngulp.task(\"test-setup-ios\", function (callback) {\n    var options = {\n        setup: true,\n        ios: true\n    };\n    \n    runTests(callback, options);\n});\n\n// Sets up the test projects and starts both emulators\ngulp.task(\"test-setup-both\", function (callback) {\n    var options = {\n        setup: true,\n        android: true,\n        ios: true\n    };\n    \n    runTests(callback, options);\n});\n\n// Builds, sets up test projects, and starts the Android emulator\ngulp.task(\"test-setup-build-android\", function (callback) {\n    runSequence(\"default\", \"test-setup-android\", callback);\n});\n\n// Builds, sets up test projects, and starts the iOS emulator\ngulp.task(\"test-setup-build-ios\", function (callback) {\n    runSequence(\"default\", \"test-setup-ios\", callback);\n});\n\n// Builds, sets up test projects, and starts both emulators\ngulp.task(\"test-setup-build-both\", function (callback) {\n    runSequence(\"default\", \"test-setup-both\", callback);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Fast Test Tasks\n//\n// Runs tests but doesn't build or start emulators.\n\n// Run on Android fast\ngulp.task(\"test-android-fast\", [\"test-setup-android\"], function (callback) {\n    runSequence(\"test-run-android\", callback);\n});\n\n// Run on iOS fast\ngulp.task(\"test-ios-fast\", [\"test-setup-ios\"], function (callback) {\n    runSequence(\"test-run-ios\", callback);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Fast Composition Test Tasks\n//\n// Run tests but doesn't build or start emulators.\n\n// Run on iOS fast\ngulp.task(\"test-fast\", [\"test-setup-both\"], function (callback) {\n    runSequence(\"test-run-android\", \"test-run-ios\", callback);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Test Tasks\n//\n// Run tests, build, and start emulators.\n\n// Run on Android\ngulp.task(\"test-android\", [\"test-setup-build-android\"], function (callback) {\n    runSequence(\"test-run-android\", callback);\n});\n\n// Run on iOS\ngulp.task(\"test-ios\", [\"test-setup-build-ios\"], function (callback) {\n    runSequence(\"test-run-ios\", callback);\n});\n\n////////////////////////////////////////////////////////////////////////\n// Composition Test Tasks\n//\n// Run tests, build, and start emulators.\n\n// Run on Android and iOS\ngulp.task(\"test\", [\"test-setup-build-both\"], function (callback) {\n    runSequence(\"test-run-android\", \"test-run-ios\", callback);\n});","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/logging.js":"/* Logs messages to console with the [CodePush] prefix */\nfunction log(message) {\n  console.log(`[CodePush] ${message}`);\n}\n\nmodule.exports = log;\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/package-mixins.js":"import { AcquisitionManager as Sdk } from \"code-push/script/acquisition-sdk\";\nimport { NativeEventEmitter } from \"react-native\";\nimport RestartManager from \"./RestartManager\";\n\n// This function is used to augment remote and local\n// package objects with additional functionality/properties\n// beyond what is included in the metadata sent by the server.\nmodule.exports = (NativeCodePush) => {\n  const remote = (reportStatusDownload) => {\n    return {\n      async download(downloadProgressCallback) {\n        if (!this.downloadUrl) {\n          throw new Error(\"Cannot download an update without a download url\");\n        }\n\n        let downloadProgressSubscription;\n        if (downloadProgressCallback) {\n          const codePushEventEmitter = new NativeEventEmitter(NativeCodePush);\n          // Use event subscription to obtain download progress.\n          downloadProgressSubscription = codePushEventEmitter.addListener(\n            \"CodePushDownloadProgress\",\n            downloadProgressCallback\n          );\n        }\n\n        // Use the downloaded package info. Native code will save the package info\n        // so that the client knows what the current package version is.\n        try {\n          const downloadedPackage = await NativeCodePush.downloadUpdate(this, !!downloadProgressCallback);\n          reportStatusDownload && reportStatusDownload(this);\n          return { ...downloadedPackage, ...local };\n        } finally {\n          downloadProgressSubscription && downloadProgressSubscription.remove();\n        }\n      },\n\n      isPending: false // A remote package could never be in a pending state\n    };\n  };\n\n  const local = {\n    async install(installMode = NativeCodePush.codePushInstallModeOnNextRestart, minimumBackgroundDuration = 0, updateInstalledCallback) {\n      const localPackage = this;\n      const localPackageCopy = Object.assign({}, localPackage); // In dev mode, React Native deep freezes any object queued over the bridge\n      await NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration);\n      updateInstalledCallback && updateInstalledCallback();\n      if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n        RestartManager.restartApp(false);\n      } else {\n        RestartManager.clearPendingRestart();\n        localPackage.isPending = true; // Mark the package as pending since it hasn't been applied yet\n      }\n    },\n\n    isPending: false // A local package wouldn't be pending until it was installed\n  };\n\n  return { local, remote };\n};","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/request-fetch-adapter.js":"const packageJson = require(\"./package.json\");\n\nmodule.exports = {\n  async request(verb, url, requestBody, callback) {\n    if (typeof requestBody === \"function\") {\n      callback = requestBody;\n      requestBody = null;\n    }\n\n    const headers = {\n      \"Accept\": \"application/json\",\n      \"Content-Type\": \"application/json\",\n      \"X-CodePush-Plugin-Name\": packageJson.name,\n      \"X-CodePush-Plugin-Version\": packageJson.version,\n      \"X-CodePush-SDK-Version\": packageJson.dependencies[\"code-push\"]\n    };\n\n    if (requestBody && typeof requestBody === \"object\") {\n      requestBody = JSON.stringify(requestBody);\n    }\n\n    try {\n      const response = await fetch(url, {\n        method: getHttpMethodName(verb),\n        headers: headers,\n        body: requestBody\n      });\n\n      const statusCode = response.status;\n      const body = await response.text();\n      callback(null, { statusCode, body });\n    } catch (err) {\n      callback(err);\n    }\n  }\n};\n\nfunction getHttpMethodName(verb) {\n  // Note: This should stay in sync with the enum definition in\n  // https://github.com/Microsoft/code-push/blob/master/sdk/script/acquisition-sdk.ts#L6\n  return [\n    \"GET\",\n    \"HEAD\",\n    \"POST\",\n    \"PUT\",\n    \"DELETE\",\n    \"TRACE\",\n    \"OPTIONS\",\n    \"CONNECT\",\n    \"PATCH\"\n  ][verb];\n}","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/RestartManager.js":"const log = require(\"./logging\");\nconst NativeCodePush = require(\"react-native\").NativeModules.CodePush;\n\nconst RestartManager = (() => {\n    let _allowed = true;\n    let _restartInProgress = false;\n    let _restartQueue = [];\n\n    function allow() {\n        log(\"Re-allowing restarts\");\n        _allowed = true;\n\n        if (_restartQueue.length) {\n            log(\"Executing pending restart\");\n            restartApp(_restartQueue.shift(1));\n        }\n    }\n\n    function clearPendingRestart() {\n        _restartQueue = [];\n    }\n\n    function disallow() {\n        log(\"Disallowing restarts\");\n        _allowed = false;\n    }\n\n    async function restartApp(onlyIfUpdateIsPending = false) {\n        if (_restartInProgress) {\n            log(\"Restart request queued until the current restart is completed\");\n            _restartQueue.push(onlyIfUpdateIsPending);\n        } else if (!_allowed) {\n            log(\"Restart request queued until restarts are re-allowed\");\n            _restartQueue.push(onlyIfUpdateIsPending);\n        } else {\n            _restartInProgress = true;\n            if (await NativeCodePush.restartApp(onlyIfUpdateIsPending)) {\n                // The app has already restarted, so there is no need to\n                // process the remaining queued restarts.\n                log(\"Restarting app\");\n                return;\n            }\n\n            _restartInProgress = false;\n            if (_restartQueue.length) {\n                restartApp(_restartQueue.shift(1));\n            }\n        }\n    }\n\n    return {\n        allow,\n        clearPendingRestart,\n        disallow,\n        restartApp\n    };\n})();\n\nmodule.exports = RestartManager;\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/generateBundledResourcesHash.js":"/*\n * This script generates a hash of all the React Native bundled assets and writes it into\n * into the APK. The hash in \"updateCheck\" requests to prevent downloading an identical\n * update to the one already present in the binary.\n *\n * It first creates a snapshot of the contents in the resource directory by creating\n * a map with the modified time of all the files in the directory. It then compares this\n * snapshot with the one saved earlier in \"recordFilesBeforeBundleCommand.js\" to figure\n * out which files were generated by the \"react-native bundle\" command. It then computes\n * the hash for each file to generate a manifest, and then computes a hash over the entire\n * manifest to generate the final hash, which is saved to the APK's assets directory.\n */\n\nvar crypto = require(\"crypto\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar getFilesInFolder = require(\"./getFilesInFolder\");\n\nvar CODE_PUSH_FOLDER_PREFIX = \"CodePush\";\nvar CODE_PUSH_HASH_FILE_NAME = \"CodePushHash\";\nvar CODE_PUSH_HASH_OLD_FILE_NAME = \"CodePushHash.json\";\nvar HASH_ALGORITHM = \"sha256\";\nvar TEMP_FILE_PATH = path.join(require(\"os\").tmpdir(), \"CodePushResourcesMap.json\");\n\nvar resourcesDir = process.argv[2];\nvar jsBundleFilePath = process.argv[3];\nvar assetsDir = process.argv[4];\nvar resourceFiles = [];\n\ngetFilesInFolder(resourcesDir, resourceFiles);\n\nvar oldFileToModifiedTimeMap = require(TEMP_FILE_PATH);\nvar newFileToModifiedTimeMap = {};\n\nresourceFiles.forEach(function(resourceFile) {\n    newFileToModifiedTimeMap[resourceFile.path.substring(resourcesDir.length)] = resourceFile.mtime;\n});\n\nvar bundleGeneratedAssetFiles = [];\n\nfor (var newFilePath in newFileToModifiedTimeMap) {\n    if (!oldFileToModifiedTimeMap[newFilePath] || oldFileToModifiedTimeMap[newFilePath] < newFileToModifiedTimeMap[newFilePath].getTime()) {\n        bundleGeneratedAssetFiles.push(newFilePath);\n    }\n}\n\nvar manifest = [];\n\nif (bundleGeneratedAssetFiles.length) {\n    bundleGeneratedAssetFiles.forEach(function(assetFile) {\n        // Generate hash for each asset file\n        addFileToManifest(resourcesDir, assetFile, manifest, function() {\n            if (manifest.length === bundleGeneratedAssetFiles.length) {\n                addJsBundleAndMetaToManifest();\n            }\n        });\n    });\n} else {\n    addJsBundleAndMetaToManifest();\n}\n\nfunction addJsBundleAndMetaToManifest() {\n    addFileToManifest(path.dirname(jsBundleFilePath), path.basename(jsBundleFilePath), manifest, function() {\n        var jsBundleMetaFilePath = jsBundleFilePath + \".meta\";\n        addFileToManifest(path.dirname(jsBundleMetaFilePath), path.basename(jsBundleMetaFilePath), manifest, function() {\n            manifest = manifest.sort();\n            var finalHash = crypto.createHash(HASH_ALGORITHM)\n                .update(JSON.stringify(manifest))\n                .digest(\"hex\");\n\n            console.log(finalHash);\n\n            var savedResourcesManifestPath = assetsDir + \"/\" + CODE_PUSH_HASH_FILE_NAME;\n            fs.writeFileSync(savedResourcesManifestPath, finalHash);\n\n            // \"CodePushHash.json\" file name breaks flow type checking.\n            // To fix the issue we need to delete \"CodePushHash.json\" file and\n            // use \"CodePushHash\" file name instead to store the hash value.\n            // Relates to https://github.com/Microsoft/react-native-code-push/issues/577\n            var oldSavedResourcesManifestPath = assetsDir + \"/\" + CODE_PUSH_HASH_OLD_FILE_NAME;\n            if (fs.existsSync(oldSavedResourcesManifestPath)) {\n                fs.unlinkSync(oldSavedResourcesManifestPath);\n            }\n        });\n    });\n}\n\nfunction addFileToManifest(folder, assetFile, manifest, done) {\n    var fullFilePath = path.join(folder, assetFile);\n    if (!fileExists(fullFilePath)) {\n        done();\n        return;\n    }\n\n    var readStream = fs.createReadStream(path.join(folder, assetFile));\n    var hashStream = crypto.createHash(HASH_ALGORITHM);\n\n    readStream.pipe(hashStream)\n        .on(\"error\", function(error) {\n            throw error;\n        })\n        .on(\"finish\", function() {\n            hashStream.end();\n            var buffer = hashStream.read();\n            var fileHash = buffer.toString(\"hex\");\n            manifest.push(path.join(CODE_PUSH_FOLDER_PREFIX, assetFile).replace(/\\\\/g, \"/\") + \":\" + fileHash);\n            done();\n        });\n}\n\nfunction fileExists(file) {\n    try { return fs.statSync(file).isFile(); }\n    catch (e) { return false; }\n}\n\nfs.unlinkSync(TEMP_FILE_PATH);\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/getFilesInFolder.js":"var fs = require(\"fs\");\nvar path = require(\"path\");\n\n// Utility function that collects the stats of every file in a directory\n// as well as in its subdirectories.\nfunction getFilesInFolder(folderName, fileList) {\n    var folderFiles = fs.readdirSync(folderName);\n    folderFiles.forEach(function(file) {\n        var fileStats = fs.statSync(path.join(folderName, file));\n        if (fileStats.isDirectory()) {\n            getFilesInFolder(path.join(folderName, file), fileList);\n        } else {\n            fileStats.path = path.join(folderName, file);\n            fileList.push(fileStats);\n        }\n    });\n}\n\nmodule.exports = getFilesInFolder;","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/recordFilesBeforeBundleCommand.js":"/*\n * This script creates a snapshot of the contents in the resource directory\n * by creating a map with the modified time of all the files in the directory\n * and saving it to a temp file. This snapshot is later referenced in \n * \"generatePackageHash.js\" to figure out which files have changed or were\n * newly generated by the \"react-native bundle\" command.\n */\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar getFilesInFolder = require(\"./getFilesInFolder\");\n\nvar TEMP_FILE_PATH = path.join(require(\"os\").tmpdir(), \"CodePushResourcesMap.json\");\n\nvar resourcesDir = process.argv[2];\nvar resourceFiles = [];\n\ntry {\n    getFilesInFolder(resourcesDir, resourceFiles);\n} catch(error) {\n    var targetPathNotFoundExceptionMessage = \"\\nResources directory path does not exist.\\n\";\n    targetPathNotFoundExceptionMessage += \"Unable to find '\" + resourcesDir;\n    targetPathNotFoundExceptionMessage += \"' directory. Please check version of Android Plugin for Gradle.\";\n    error.message += targetPathNotFoundExceptionMessage;\n    throw error;\n}\n\nvar fileToModifiedTimeMap = {};\n\nresourceFiles.forEach(function(resourceFile) {\n    fileToModifiedTimeMap[resourceFile.path.substring(resourcesDir.length)] = resourceFile.mtime.getTime();\n});\n\nfs.writeFile(TEMP_FILE_PATH, JSON.stringify(fileToModifiedTimeMap), function(err) {\n    if (err) {\n        throw err;\n    }\n}); ","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/postlink/run.js":"require(\"./ios/postlink\");\nrequire(\"./android/postlink\");","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/postlink/ios/postlink.js":"var fs = require(\"fs\");\nvar glob = require(\"glob\");\nvar inquirer = require('inquirer');\nvar path = require(\"path\");\nvar plist = require(\"plist\");\nvar xcode = require(\"xcode\");\n\nvar package = require('../../../../../package.json');\n\nvar ignoreNodeModules = { ignore: \"node_modules/**\" };\nvar appDelegatePaths = glob.sync(\"**/AppDelegate.+(mm|m)\", ignoreNodeModules);\n\n// Fix for https://github.com/Microsoft/react-native-code-push/issues/477\n// Typical location of AppDelegate.m for newer RN versions: $PROJECT_ROOT/ios/<project_name>/AppDelegate.m\n// Let's try to find that path by filtering the whole array for any path containing <project_name>\n// If we can't find it there, play dumb and pray it is the first path we find.\nvar appDelegatePath = findFileByAppName(appDelegatePaths, package ? package.name : null) || appDelegatePaths[0];\n\nif (!appDelegatePath) {\n    console.log(`Couldn't find AppDelegate. You might need to update it manually \\\nPlease refer to plugin configuration section for iOS at \\\nhttps://github.com/microsoft/react-native-code-push#plugin-configuration-ios`);\n    return;\n}\n\nvar appDelegateContents = fs.readFileSync(appDelegatePath, \"utf8\");\n\n// 1. Add the header import statement\nvar codePushHeaderImportStatement = `#import <CodePush/CodePush.h>`;\nif (~appDelegateContents.indexOf(codePushHeaderImportStatement)) {\n    console.log(`\"CodePush.h\" header already imported.`);\n} else {\n    var appDelegateHeaderImportStatement = `#import \"AppDelegate.h\"`;\n    appDelegateContents = appDelegateContents.replace(appDelegateHeaderImportStatement,\n        `${appDelegateHeaderImportStatement}\\n${codePushHeaderImportStatement}`);\n}\n\n// 2. Modify jsCodeLocation value assignment\nvar oldJsCodeLocationAssignmentStatement = appDelegateContents.match(/(jsCodeLocation = .*)/)[1];\nvar newJsCodeLocationAssignmentStatement = \"jsCodeLocation = [CodePush bundleURL];\";\nif (~appDelegateContents.indexOf(newJsCodeLocationAssignmentStatement)) {\n    console.log(`\"jsCodeLocation\" already pointing to \"[CodePush bundleURL]\".`);\n} else {\n    var jsCodeLocationPatch = `\n#ifdef DEBUG\n    ${oldJsCodeLocationAssignmentStatement}\n#else\n    ${newJsCodeLocationAssignmentStatement}\n#endif`;\n    appDelegateContents = appDelegateContents.replace(oldJsCodeLocationAssignmentStatement,\n        jsCodeLocationPatch);\n}\n\nvar plistPath = getPlistPath();\n\nif (!plistPath) {\n    console.log(`Couldn't find .plist file. You might need to update it manually \\\nPlease refer to plugin configuration section for iOS at \\\nhttps://github.com/microsoft/react-native-code-push#plugin-configuration-ios`);\n    return;\n}\n\nvar plistContents = fs.readFileSync(plistPath, \"utf8\");\n\n// 3. Add CodePushDeploymentKey to plist file\nvar parsedInfoPlist = plist.parse(plistContents);\nif (parsedInfoPlist.CodePushDeploymentKey) {\n    console.log(`\"CodePushDeploymentKey\" already specified in the plist file.`);\n    writePatches();\n} else {\n    inquirer.prompt({\n        \"type\": \"input\",\n        \"name\": \"iosDeploymentKey\",\n        \"message\": \"What is your CodePush deployment key for iOS (hit <ENTER> to ignore)\"\n    }).then(function(answer) {\n        parsedInfoPlist.CodePushDeploymentKey = answer.iosDeploymentKey || \"deployment-key-here\";\n        plistContents = plist.build(parsedInfoPlist);\n\n        writePatches();\n    });\n}\n\nfunction writePatches() {\n    fs.writeFileSync(appDelegatePath, appDelegateContents);\n    fs.writeFileSync(plistPath, plistContents);\n}\n\n// Helper that filters an array with AppDelegate.m paths for a path with the app name inside it\n// Should cover nearly all cases\nfunction findFileByAppName(array, appName) {\n    if (array.length === 0 || !appName) return null;\n\n    for (var i = 0; i < array.length; i++) {\n        var path = array[i];\n        if (path && path.indexOf(appName) !== -1) {\n            return path;\n        }\n    }\n\n    return null;\n}\n\nfunction getDefaultPlistPath() {\n    //this is old logic in case we are unable to find PLIST from xcode/pbxproj - at least we can fallback to default solution\n    return glob.sync(`**/${package.name}/*Info.plist`, ignoreNodeModules)[0];\n}\n\n// This is enhanced version of standard implementation of xcode 'getBuildProperty' function  \n// but allows us to narrow results by PRODUCT_NAME property also. \n// So we suppose that proj name should be the same as package name, otherwise fallback to default plist path searching logic\nfunction getBuildSettingsPropertyMatchingTargetProductName(parsedXCodeProj, prop, targetProductName, build){\n    var target;\n    var COMMENT_KEY = /_comment$/;\n    var PRODUCT_NAME_PROJECT_KEY = 'PRODUCT_NAME';\n\n    if (!targetProductName){\n        return target;\n    }\n\n    var configs = parsedXCodeProj.pbxXCBuildConfigurationSection();\n    for (var configName in configs) {\n        if (!COMMENT_KEY.test(configName)) {\n            var config = configs[configName];\n            if ( (build && config.name === build) || (build === undefined) ) {\n                if (config.buildSettings[prop] !== undefined && config.buildSettings[PRODUCT_NAME_PROJECT_KEY] == targetProductName) {\n                    target = config.buildSettings[prop];\n                }\n            }\n        }\n    }\n    return target;\n}\n\nfunction getPlistPath(){\n    var xcodeProjectPaths = glob.sync(`**/*.xcodeproj/project.pbxproj`, ignoreNodeModules);\n    if (!xcodeProjectPaths){\n        return getDefaultPlistPath();\n    }\n\n    if (xcodeProjectPaths.length !== 1) {\n        console.log('Could not determine correct xcode proj path to retrieve related plist file, there are multiple xcodeproj under the solution.');\n        return getDefaultPlistPath();\n    }\n\n    var xcodeProjectPath = xcodeProjectPaths[0];\n    var parsedXCodeProj;\n\n    try {\n        var proj = xcode.project(xcodeProjectPath);      \n        //use sync version because there are some problems with async version of xcode lib as of current version\n        parsedXCodeProj = proj.parseSync();\n    }\n    catch(e) {\n        console.log('Couldn\\'t read info.plist path from xcode project - error: ' + e.message);\n        return getDefaultPlistPath();\n    }\n\n    var INFO_PLIST_PROJECT_KEY = 'INFOPLIST_FILE';\n    var RELEASE_BUILD_PROPERTY_NAME = \"Release\";\n    var targetProductName = package ? package.name : null;\n\n    //Try to get 'Release' build of ProductName matching the package name first and if it doesn't exist then try to get any other if existing\n    var plistPathValue = getBuildSettingsPropertyMatchingTargetProductName(parsedXCodeProj, INFO_PLIST_PROJECT_KEY, targetProductName, RELEASE_BUILD_PROPERTY_NAME) || \n        getBuildSettingsPropertyMatchingTargetProductName(parsedXCodeProj, INFO_PLIST_PROJECT_KEY, targetProductName) ||\n         parsedXCodeProj.getBuildProperty(INFO_PLIST_PROJECT_KEY, RELEASE_BUILD_PROPERTY_NAME) || \n         parsedXCodeProj.getBuildProperty(INFO_PLIST_PROJECT_KEY);\n\n    if (!plistPathValue){\n        return getDefaultPlistPath();\n    }\n\n    return path.resolve(path.dirname(xcodeProjectPath), '..', plistPathValue);    \n}\n","/home/travis/build/npmtest/node-npmtest-react-native-code-push/node_modules/react-native-code-push/scripts/postlink/android/postlink.js":"var fs = require(\"fs\");\nvar glob = require(\"glob\");\nvar path = require(\"path\");\n\nvar ignoreFolders = { ignore: [\"node_modules/**\", \"**/build/**\"] };\nvar buildGradlePath = path.join(\"android\", \"app\", \"build.gradle\");\nvar manifestPath = glob.sync(\"**/AndroidManifest.xml\", ignoreFolders)[0];\n\nfunction findMainApplication() {\n    if (!manifestPath) {\n        return null;\n    }\n\n    var manifest = fs.readFileSync(manifestPath, \"utf8\");\n\n    // Android manifest must include single 'application' element\n    var matchResult = manifest.match(/application\\s+android:name\\s*=\\s*\"(.*?)\"/);\n    if (matchResult) {\n        var appName = matchResult[1];\n    } else {\n        return null;\n    }\n    \n    var nameParts = appName.split('.');\n    var searchPath = glob.sync(\"**/\" + nameParts[nameParts.length - 1] + \".java\", ignoreFolders)[0];\n    return searchPath;\n}\n\nvar mainApplicationPath = findMainApplication() || glob.sync(\"**/MainApplication.java\", ignoreFolders)[0];\n\n// 1. Add the getJSBundleFile override\nvar getJSBundleFileOverride = `\n    @Override\n    protected String getJSBundleFile() {\n      return CodePush.getJSBundleFile();\n    }\n`;\n\nfunction isAlreadyOverridden(codeContents) {\n    return /@Override\\s*\\n\\s*protected String getJSBundleFile\\(\\)\\s*\\{[\\s\\S]*?\\}/.test(codeContents);\n}\n\nif (mainApplicationPath) {\n    var mainApplicationContents = fs.readFileSync(mainApplicationPath, \"utf8\");\n    if (isAlreadyOverridden(mainApplicationContents)) {\n        console.log(`\"getJSBundleFile\" is already overridden`);\n    } else {\n        var reactNativeHostInstantiation = \"new ReactNativeHost(this) {\";\n        mainApplicationContents = mainApplicationContents.replace(reactNativeHostInstantiation,\n            `${reactNativeHostInstantiation}\\n${getJSBundleFileOverride}`);\n        fs.writeFileSync(mainApplicationPath, mainApplicationContents);\n    }\n} else {\n    var mainActivityPath = glob.sync(\"**/MainActivity.java\", ignoreFolders)[0];\n    if (mainActivityPath) {\n        var mainActivityContents = fs.readFileSync(mainActivityPath, \"utf8\");\n        if (isAlreadyOverridden(mainActivityContents)) {\n            console.log(`\"getJSBundleFile\" is already overridden`);\n        } else {\n            var mainActivityClassDeclaration = \"public class MainActivity extends ReactActivity {\";\n            mainActivityContents = mainActivityContents.replace(mainActivityClassDeclaration,\n                `${mainActivityClassDeclaration}\\n${getJSBundleFileOverride}`);\n            fs.writeFileSync(mainActivityPath, mainActivityContents);\n        }\n    } else {\n        console.error(`Couldn't find Android application entry point. You might need to update it manually. \\\nPlease refer to plugin configuration section for Android at \\\nhttps://github.com/microsoft/react-native-code-push#plugin-configuration-android for more details`);\n    }\n}\n\nif (!fs.existsSync(buildGradlePath)) {\n    console.error(`Couldn't find build.gradle file. You might need to update it manually. \\\nPlease refer to plugin installation section for Android at \\\nhttps://github.com/microsoft/react-native-code-push#plugin-installation-android---manual`);\n    return;\n}\n\n// 2. Add the codepush.gradle build task definitions\nvar buildGradleContents = fs.readFileSync(buildGradlePath, \"utf8\");\nvar reactGradleLink = buildGradleContents.match(/\\napply from: [\"'].*?react\\.gradle[\"']/)[0];\nvar codePushGradleLink = `apply from: \"../../node_modules/react-native-code-push/android/codepush.gradle\"`;\nif (~buildGradleContents.indexOf(codePushGradleLink)) {\n    console.log(`\"codepush.gradle\" is already linked in the build definition`);\n} else {\n    buildGradleContents = buildGradleContents.replace(reactGradleLink,\n        `${reactGradleLink}\\n${codePushGradleLink}`);\n    fs.writeFileSync(buildGradlePath, buildGradleContents);\n}"}